.page-header
  h1
    | Meeting #{@meeting.name}

p
  strong= Meeting.human_attribute_name(:description) + ':'
  br
  = @meeting.description
p
  strong= Meeting.human_attribute_name(:end_at) + ':'
  br
  = @meeting.end_at
p
  strong= Meeting.human_attribute_name(:user_id) + ':'
  br
  = @meeting.user_name

- if current_user.has_meeting? @meeting
  = render partial: "form_date"

- users = @meeting.users.order(:id).uniq.to_a
table.table-condensed.poll
  thead
    tr
      th
      - users.each do |user|
        td user_id="#{user.id}"
          small= user.name + " (#{user.id})"
  tbody
    / sort is done by Ruby. It does allow slq optimisation via joins
    - @meeting.meeting_dates.sort_by(&:date).each_with_index do |meeting_date|
      tr meeting_date_id="#{meeting_date.id}"
        th= meeting_date.date
        - dates = meeting_date.user_dates.to_a
        - users.map(&:id).each do |user_id|
          - user_date = dates.find{|d| d.user_id == user_id}
          - present = user_date&.state
          td class="#{UserDate::STATE[present] || 'bg-danger'} user_date" user_date_id="#{user_date&.id}" user_id="#{user_id}"
