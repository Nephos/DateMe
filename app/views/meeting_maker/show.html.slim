.page-header
  h1
    | Meeting #{@meeting.name}

p
  strong= Meeting.human_attribute_name(:description) + ':'
  br
  = @meeting.description
p
  strong= Meeting.human_attribute_name(:end_at) + ':'
  br
  = @meeting.end_at
p
  strong= Meeting.human_attribute_name(:user_id) + ':'
  br
  = @meeting.user_name
p
  strong= Meeting.human_attribute_name(:uuid) + ':'
  br
  = @meeting.uuid

- if current_user.has_meeting? @meeting
  = render partial: "form_date"
- if @meeting.users.include? current_user
  = link_to "Unsubscribe", meeting_unsubscribe_path(@meeting.uuid), method: "DELETE", class: "btn btn-danger"
- else
  = link_to "Subscribe", meeting_subscribe_path(@meeting.uuid), method: "POST", class: "btn btn-success"

- users = @meeting.users.order(:id).uniq.to_a
table.table-condensed.poll
  thead
    tr
      th
      /- users.each do |user|
        td user_id="#{user.id}"
          small= user.name + " (#{user.id})"
  tbody
    / sort is done by Ruby. It does allow slq optimisation via joins
    - @meeting.meeting_dates.sort_by(&:date).each_with_index do |meeting_date|
      tr meeting_date_id="#{meeting_date.id}"
        th
          - if current_user.has_meeting? @meeting
            = link_to 'x', meeting_rm_date_path(meeting_date), :method => :delete, :class => 'btn btn-xs btn-danger'
            |  
          = meeting_date.date_formated
        - dates = meeting_date.user_dates.to_a
        - users.map(&:id).each do |user_id|
          - user_date = dates.find{|d| d.user_id == user_id}
          - present = user_date&.state
          td class="#{UserDate::STATE[present] || 'bg-info'} user_date" user_date_id="#{user_date&.id}" user_id="#{user_id}"
